#Python学习笔记3

# 1.函数

### 1.1系统函数

`abs()`返回绝对值；`ceil()`向上取整；`floor()`向下取整；`exp()`返回e的x次幂；`max()`返回最大值；`min()`返回最小值；`pow(x,y)`返回x的y次幂；`round(x,n)`返回浮点数x四舍五入后的n位数；`sqrt()`返回平方根，注：运用ceil，sqrt，exp，floor时需导入math包

随机数函数`random()`（需导入random包）

```python
random.randint(a,b)#产生a-b间的随机数
random.choice([a,b,c,d])#在a,b,c,d间随机选择
random.random()#产生0-1之间的数
```

### 1.2自定义函数

一个简单的求和函数：

```python
#求和函数
def sum(i):
	sum = 0
	while(i>0):
		sum+=i
		i-=1
	return sum
print(sum(10))
#输出为：55
```

可以看到，python中定义函数用`def 函数名(参数1,参数2,...)`来确定，遵循以下几点要求： 

- 确定函数名和参数个数
- 检查参数的数据类型
- 可以用`return`随时返回函数结果
- 即使没有`return`语句时，自动`return None`
- 函数可以同时返回多个值，本质上是一个tuple，tuple的()可以省略

```python
import math
#求解函数
def qua(a,b,c):
	x1=(-b+math.sqrt(b*b-4*a*c))/2
	x2=(-b-math.sqrt(b*b-4*a*c))/2
	return x1,x2
print(qua(1,0,-1))
print(qua(1,-2,1))
#输出为：(1.0, -1.0)   (1.0, 1.0)
```

在上述求和函数中，如果输入`print(sum(a))`，与函数参数类型不符，则会报错，`print(sum(a)) NameError: name 'a' is not defined`，而在求解函数中，输入`print(qua(1,0,1))`，也会报错，`x1=(-b+math.sqrt(b*b-4*a*c))/2 ValueError: math domain error`，这是因为在开根号过程中，根号内出现了负号，对此，编译器会自行判断，在出现错误时报出错误，停止编译。

# 2.函数参数

## 2.1默认参数

前面说到，定义一个函数，首先要确定函数名和函数参数，函数名是为了更直观的了解函数的作用，而函数参数则是传递需求，再由return返回结果。例如，求x的平方：

```python
def pow(x):
	return x*x
print(pow(3))
#输出为：9
```

可是，当要求x的3次方，4次方又怎么办呢？这时可以多加一个函数参数n

```python
def pow(x,n=2):
	result = 1
	while(n>0):
	   result *= x
	   n-=1
	return result
print(pow(3,3))
print(pow(4))
#输出为：27  16
```

为了使传入1个参数或2个参数都可以运行，可以将n设置为默认参数，当有第2个参数时，覆盖其值，没有时默认为2，可以大大简化函数的调用。关于默认参数的设置，遵循以下规则：

- 必选参数在前，默认参数在后
- 函数有多个参数时，把变化大的参数放前面，变化小的参数放后面。变化小的参数就可以作为默认参数
- 默认参数必须指向不变对象

## 2.2可变参数(*args)

当不确定要传入的函数参数个数时，可以选择用可变参数，此时，参数`numbers`接收到的是一个tuple 

```python
def calc(*numbers):
	sum = 0
	for i in numbers:
		sum +=i
	return sum
print (calc(1,2,3,4,5))
print (calc(1,2))
#输出为：15  3
```

参数还可以直接是一个`list`或`tuple`

```python
num = [3,7]
print(calc(*num))
#输出为：10
```

## 2.3关键字参数(**kw)

关键字参数可以允许传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict 。

```python
def output(name,sex,age,**other):
	print('name:',name,'sex:',sex,'age:',age,'other:',other)
output('喵','女',19)
output('喵喵','女',18,hobby1='钢琴',hobby2='喵咪')
#输出为：name: 喵 sex: 女 age: 19 other: {}
#name: 喵喵 sex: 女 age: 18 other: {'hobby1': '钢琴', 'hobby2': '喵咪'}
```

可以看出，对于关键字参数，可以传入任意个参数。 正是因为这一点，关键字参数的功能就是扩展函数，正如上面的例子，除`name`、`sex`、`age`这几个必填参数外，其他都是选填，甚至可以不填，大大增强了函数拓展性。

当然，也可以先组装一个`dict`，再将其传入函数

```python
hobby={'book':'小王子','sport':'无'}
output('哇哇','女',20,**hobby)
#输出为：name: 哇哇 sex: 女 age: 20 other: {'book': '小王子', 'sport': '无'}
```

# 3.递归函数

```python
#递归函数
def fun(n):
	if n==1 or n==0:
		return 1
	else:
		return n*fun(n-1)
print(fun(6))
#输出为：720
```

可以看出，使用递归函数的优点是逻辑简单清晰，但缺点是过深的调用会导致栈溢出。 

用递归函数实现[汉诺塔](http://baike.baidu.com/view/191666.htm)的移动

```python
def move(n,a,b,c):
	if n==1:
		print(a,'-->',c)
	else:
		move(n-1,a,c,b)
		move(1,a,b,c)
		move(n-1,b,a,c)
move(3,'A','B','C')
```

输出

```python
A --> C
A --> B
C --> B
A --> C
B --> A
B --> C
A --> C
```

提示：关于汉诺塔递归的思考

有三根杆子A，B，C。A杆上有N个(N>1)穿孔圆盘，盘的尺寸由下到上依次变小。要求按下列规则将所有圆盘移至C杆： 1.每次只能移动一个圆盘. 2.大盘不能叠在小盘上面. 我以前都是用类似演绎的方法去思考的，比如1个盘是怎样的移动，2个盘是怎样的移动，3个盘是怎样的移动……然后再来找其中共同的规律。好像也没有不可以，不过比较繁琐，而且这题既然是递归的常用例子，还是用递归来想想。

注意关键点：

2.大盘不能叠在小盘上面. 想通了（当然也是在搜索和思考后），其实这个问题可以分解成三步，假设A杆上有n个盘，第一步把A杆上面的n-1个盘移动到B杆；第二步，那么就剩最后也是最大的那一个盘，我们就把它直接从A杆移动到C杆；第三步，把剩下的n-1个盘从B杆移动到C杆。

基本的移动思路有了，我们来想象一下，当有n-1个盘在A杆时，也是使用这样的三步来使圆盘移动到C杆上，只是第一步变成了移动n-2个盘到B杆，第三步变成把剩下n-2个盘从B杆移动到C杆；当有n-2个盘在A杆时，上述两步的移动数就变成了n-3；……；以此类推，当剩下2个盘在A杆时，第一步就是把2-1=1个盘移动到B杆，然后把剩下的1个盘从A杆移动到C杆，最后再把B杆上的一个盘移到C杆；当剩下一个盘在A杆时，就是只有一步操作了，直接从A杆移动到C杆！

是不是发现了什么？嗯，没错，不管有几个盘，最后都可以推演到剩下一个盘的情况。我们再来看一下上面提的三步操作，当n=3，第二步自然是从A移到C，然后第一步和第三步都是移动两个盘，而移动两个盘的情况，就是我们上面提的：

当剩下2个盘在A杆时，第一步就是把2-1=1个盘移动到B杆，然后把剩下的1个盘从A杆移动到C杆，最后再把B杆上的一个盘移到C杆 移动两个盘又可以看成三次移动一个盘的情况，所以n=3时，总共需要3+1+3=7步。

贴一段找到的实现的代码：

def move(n,a,b,c): if n==1: print(a,"--->",c) else: move(n-1,a,c,b) move(1,a,b,c) move(n-1,b,a,c) 嗯，其实我也是想不出来的，还是说说最后3个move（）怎么理解吧/(ㄒoㄒ)/~~

其实是对应了上面说的三个步骤，其中第二步不用解释了，就是剩一个盘在A杆的情况；第一步就是怎么把A杆的n-1个盘移到B杆，第三步就是怎么把B杆的n-1个盘移到C杆；

move(n,a,b,c)是一个定义的函数，其中n代表A杆上有几个盘，a变量代表你要从哪里开始移动的那个杆，c变量代表要移到哪里的那个杆，b变量就代表过渡的那个杆；

当n=1时，“print（a,"-->",c）就是从出发杆移到目的杆，当这里的a和c是变量，是你输入时决定的名称，不是我们题目里的a和c，你自己开心叫阿猫阿狗都可以；这也是我一开始的疑惑，明明只有a-->c，为什么可以输出b-->c？理解了只是变量之后就好理解了。

当n<>1时，因为我们上面已经推出结论了，任意的大于1的n都可以由n-1得到最终可以由n=1得到，所以第一个的move（n-1,a,c,b），因为最后还是回到n=1来，所以这里a=A，c=B，b=C，出发点是a杆，目的杆是b杆，所以使用了a,c,b的排列，同理第三步move（n-1,b,a,c）的出发点是b杆，目的点是c杆，所以使用了b，a，c的排列。